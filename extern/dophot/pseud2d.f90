! The model used in DoPHOT for the surface-brightness profiles of stellar images
! consists of similar ellipses of the form
! I(x,y) = I0 * ( 1 + z**2 + beta4/2*(z**2)**2 + beta6/6*(z**2)**3 )**(-1) * Is
! where
! z**2 = 1/2 * (x**2/sigx**2 + 2*sigxy*x*y + y**2/sigy**2)
! and 
! x = x' - x0 ; y = y'-y0
! with the nominal center of the image at (x0,y0)
! For a more thorough explanation See section 4.2 in the DoPHOT paper 
! (Schechter, Mateo, and Saha 1993 PASP, 105, 1345)
! A wide variety of PSFs can be generated by an appropiate choice of values.
! There are seven free parameters in this function that are transported 
! through the different functions and subroutines in an array of 7 elements:
! 1 - the background intensity Is (sky) 
! 2 - the central intensity I0
! 3 - the object center in x, x0
! 4 - the object center in y, y0
! 5 - the shape parameter sigx (actually, sigx**2)
! 6 - the shape parameter sigxy
! 7 - the shape parameter sigy (actually, sigy**2)
!
!---------------------------------------------------------------------------
!---------------------------------------------------------------------------
! This file contains the subroutines
!
! PSEUD2D
! PSEUD2D_TWO
!
!---------------------------------------------------------------------------
!---------------------------------------------------------------------------
!
! Subroutine pseud2d(xy,a,m,beta4,beta6,> fa,pseud2dval)
!
! This subroutine calculates the values for the I(x,y) using 
! the pseudo 2-dimensional gaussian described above,
! along with the partial derivatives of the fit function with respect 
! to the parameters.
! Notice that to for proper programming m should be at least 7

subroutine pseud2d(xy,a,m,beta4,beta6,fa,pseud2dval)

  real, parameter ::  half=0.5,third=0.3333333,expmin=-23.
  real :: xy(2)
  real :: a(m),fa(m)

  x = xy(1)-a(3)
  y = xy(2)-a(4)

  if((a(5).eq.0).or.(a(7).eq.0)) write(6,*) 'Divide by Zero 16'
  a5 = 1.0/a(5)
  a7 = 1.0/a(7)
  t5 = a5*x
  t6 = a(6)*y
  t7 = a7*y
  t1 = half*((t5+2*t6)*x+t7*y)              !z**2 from explanation above
  if(t1.gt.0) then
     t2 = t1*t1*half
     den = 1+t1+beta4*t2+(beta6*third)*t1*t2      !Denominator of I(x,y)
     ddendt1 = 1+beta4*t1+beta6*t2                !Partial derivative   
     if(den.eq.0) write(6,*) 'Divide by Zero 17'
     pexp = 1.0/den
  else
     t1 = amax1(t1,expmin)
     pexp = exp(-t1)
     den = 1.0
     ddendt1 = 1.0
  end if

  pseud2dval = a(2)*pexp+a(1)
  
  if(den.eq.0) write(6,*) 'Divide by Zero 18'
  dIdt1 = a(2)*pexp*ddendt1/den     !Actually -dIdt1, but taken care in fa()
  ! fa() is the derivative of function I(x,y) with respect to the parameters
  fa(1) = 1.0
  fa(2) = pexp
  fa(3) = (t5+t6)*dIdt1
  fa(4) = (a(6)*x+t7)*dIdt1
  fa(5) = half*t5**2*dIdt1
  fa(6) = -x*y*dIdt1
  fa(7) = half*t7**2*dIdt1

end subroutine pseud2d

!-----------------------------------------------------------------------
!
! Subroutine pseud2d_two(xy,b,m,beta4,beta6,> fb,pseud2dtwo_val)
!
! This subroutine calculates the values for the I(x,y) using 
! a model of 2 pseudo 2-dimensional gaussian, along with
! the partial derivatives of the fit function with respect 
! to the parameters.
! It is used to check for blends of two closed stars.
! Notice that the parameter number in b is increased by 3 more with respect
! to pseud2d a, and that the new parameters have meanings
! b(1)=a(1);log(b(2))=log(b(5))=a(2);b(3)=b(6)=a(3);b(4)=b(7)=a(4);
! b(8)=a(5);b(9)=a(6);b(10)=a(7).
! Notice that to for proper programming m should be at least 10
! To better understand this function check subroutine PSEUD2D above, and
! subroutine SHAPE

subroutine pseud2d_two(xy,b,m,beta4,beta6,fb,pseud2d_twoval)

  real, parameter ::  half=0.5,third=0.3333333,expmin=-35.0
  real :: xy(2)
  real :: b(m),fb(m),pp(2)

  if(b(8).eq.0.or.b(10).eq.0.) write(6,*) 'Divide by Zero 19'
  b8 = 1./b(8)
  b10 = 1./b(10)
  do i = 1,2
     ioff = (i-1)*3
     x = xy(1)-b(3+ioff)       ! First loop b(3), second loop b(6)
     y = xy(2)-b(4+ioff)       ! First loop b(4), second loop b(7)
     t8 = b8*x
     t9 = b(9)*y
     t10 = b10*y
     t1 = half*((t8+2*t9)*x+t10*y)
     if (t1.gt.0) then
        t2 = t1*t1*half
        den = 1+t1+beta4*t2+(beta6*third)*t1*t2
        ddendt1 = 1+beta4*t1+beta6*t2
        if(den.eq.0) write(6,*) 'Divide by Zero 20'
        pexp = 1/den
     else
        t1 = amax1(t1,expmin)
        pexp = exp(-t1)
        den = 1.0
        ddendt1 = 1.0
     end if

     b2 = exp(b(2+ioff))       ! First loop b(2), second loop b(5)
     pp(i) = b2*pexp

     if(den.eq.0) write(6,*) 'Divide by Zero 21'
     dIdt1 = pp(i)*ddendt1/den
!    fb() is the derivative of function I(x,y) with respect to the parameters
!    Notice that we do not calculate fb(8), fb(9), and fb(10) because we are
!    not trying to use subroutine CHISQ later to refine b(8), b(9), and b(10)
     fb(2+ioff) = pp(i)          ! = b2*pexp, because is dI/db(2), not dI/db2
     fb(3+ioff) = (t8+t9)*dIdt1
     fb(4+ioff) = (b(9)*x+t10)*dIdt1

  end do

  fb(1) = 1
  pseud2d_twoval = pp(1) + pp(2) + b(1)

end subroutine pseud2d_two

